@using MagicPropsComponents.Utilities.Extensions
@using MagicPropsComponents.ViewModels.Popup
@using Microsoft.JSInterop
@using MagicPropsComponents.Abstractions
@implements IMPPopup
@inject IJSRuntime JSRuntime
<CascadingValue Value="this" Name="MPPopup">


    <div class="popup" @ref="_popupModelEle" style="@GetStyle()" id="@_popupEleID">
        @if (ShowCloseButton)
        {
            <div style="height:20px;width:100%;display:flex;justify-content: right;padding-right: 10px;margin-bottom: 10px;">
                <i class="fa fa-close" @onclick="SetPopupInvisible"></i>
            </div>
        }
        @if (ChildContent != null)
        {
            @ChildContent
        }
        else
        {
            <h3>This is Popup Content, please add ChildContent to fill.</h3>
        }
    </div>
</CascadingValue>
@code {
    private ElementReference? _triggerRootEle;
    private ElementReference? _popupModelEle;
    [Parameter]
    public int? Width { get; set; }
    [Parameter]
    public int? Height { get; set; }
    [Parameter]
    public string TriggerEleID { get; set; } = string.Empty;
    private string _popupEleID { get; set; } = string.Empty;

    [Parameter]
    public bool ShowCloseButton { get; set; } = false;

    [Parameter]
    public string PopupShadowSettings { get; set; } = "0 0 5px rgba(0,0,0,.5)";
    [Parameter]
    public int? Spacing { get; set; } = 5;
    [Parameter]
    public int Padding { get; set; } = 10;
    [Parameter]
    public int BorderRadius { get; set; } = 10;
    [Parameter]
    public string BorderSettings { get; set; } = "1px solid #dee2e6";

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public AnchorPointType AnchorPointType { get; set; } = AnchorPointType.TriggerRightTop;
    [Parameter]
    public decimal AnchorPointX { get; set; } = -1;
    [Parameter]
    public decimal AnchorPointY { get; set; } = -1;
    [Parameter]
    public PopupToward Toward { get; set; } = PopupToward.BottomRight;

    private bool _visiable = false;
    [Parameter]
    public bool Visible
    {
        get => _visiable;
        set
        {
            if (_visiable != value)
            {
                _visiable = value;
                _ = Task.Run(() => OnVisiableChanged(value));
                VisibleChanged.InvokeAsync(value);
                StateHasChanged();
            }
        }
    }
    [Parameter]
    public bool OnlyControlByVisible { get; set; } = false;

    [Parameter]
    public EventCallback<bool> VisibleChanged { get; set; }

    [Parameter]
    public Action? OnAfterPopupRender { get; set; }
    [Parameter]
    public Action? OnAfterHidePopup { get; set; }

    [Parameter]
    public Func<Task>? OnAfterHidePopupAsync { get; set; }
    [Parameter]
    public Func<Task>? OnAfterPopupRenderAsync { get; set; }

    [JSInvokable]
    public async Task SetPopupVisible()
    {
        Visible = true;
        await Task.Delay(10);
    }
    public async Task OnVisiableChanged(bool visible)
    {
        if (visible)
        {
            await JSRuntime.InvokeAsync<object>("MPPOPUP.showById", _popupModelEle, TriggerEleID, Toward.GetDescription(), AnchorPointX, AnchorPointY, AnchorPointType.GetDescription(), _popupEleID, PopupShadowSettings, Spacing, OnlyControlByVisible);
        }
        else
        {
            await JSRuntime.InvokeAsync<object>("MPPOPUP.hide", _popupEleID, _popupModelEle);

            if (OnAfterHidePopup != null || OnAfterHidePopupAsync != null)
            {
                if (OnAfterHidePopup != null)
                {
                    OnAfterHidePopup.Invoke();
                }
                if (OnAfterHidePopupAsync != null)
                {
                    await OnAfterHidePopupAsync.Invoke();
                }
                StateHasChanged();
            }
        }
    }
    private string GetStyle()
    {
        var style = "border:" + BorderSettings + ";";
        if (Width != null && Width > 0)
        {
            style += "width:" + Width + "px;";
        }
        if (Height != null && Height > 0)
        {
            style += "height:" + Height + "px;";
        }
        if (BorderRadius >= 0)
        {
            style += "border-radius:" + BorderRadius + "px;";
        }
        if (Padding >= 0)
        {
            style += "padding:" + Padding + "px;";
        }
        return style;
    }

    [JSInvokable]
    public async Task SetPopupInvisible()
    {
        Visible = false;
        await Task.Delay(10);
    }

    protected override async Task OnInitializedAsync()
    {
        _popupEleID = "popup_" + Guid.NewGuid().ToString().Replace("-", "");
        await JSRuntime.InvokeVoidAsync("registerDotNetMethod", _popupEleID, DotNetObjectReference.Create(this));
        if (!string.IsNullOrEmpty(TriggerEleID))
        {
            await JSRuntime.InvokeAsync<object>("MPPOPUP.initialTriggerEventById", this.TriggerEleID, _popupEleID, OnlyControlByVisible);
        }
        else
        {
            throw new Exception("TriggerEleID is required.");
        }
        if (Visible)
        {
            await OnVisiableChanged(true);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (OnAfterPopupRender != null || OnAfterPopupRenderAsync != null)
        {
            if (OnAfterPopupRender != null)
            {
                OnAfterPopupRender.Invoke();
            }
            if (OnAfterPopupRenderAsync != null)
            {
                await OnAfterPopupRenderAsync.Invoke();
            }
            StateHasChanged();
        }
    }
}
